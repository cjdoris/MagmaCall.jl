<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Guide · MagmaCall</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MagmaCall</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">MagmaCall.jl</a></li><li class="is-active"><a class="tocitem" href>Guide</a><ul class="internal"><li><a class="tocitem" href="#Syntax"><span>Syntax</span></a></li><li><a class="tocitem" href="#Conversion-to-Magma"><span>Conversion to Magma</span></a></li><li><a class="tocitem" href="#Conversion-to-Julia"><span>Conversion to Julia</span></a></li><li><a class="tocitem" href="#Calling-functions-and-procedures"><span>Calling functions and procedures</span></a></li></ul></li><li><a class="tocitem" href="../reference/">API Reference</a></li><li><a class="tocitem" href="../how/">How it works</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Guide</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/cjdoris/MagmaCall.jl/blob/master/docs/src/guide.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Guide"><a class="docs-heading-anchor" href="#Guide">Guide</a><a id="Guide-1"></a><a class="docs-heading-anchor-permalink" href="#Guide" title="Permalink"></a></h1><h2 id="Syntax"><a class="docs-heading-anchor" href="#Syntax">Syntax</a><a id="Syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Syntax" title="Permalink"></a></h2><p>The following tables gives the mapping between Magma and Julia syntax.</p><table><tr><th style="text-align: left">Magma</th><th style="text-align: left">Julia</th></tr><tr><td style="text-align: left"><code>r := Intrinsic(x, y: opt:=z)</code></td><td style="text-align: left"><code>r = magf.Intrinsic(x, y, opt=z)</code></td></tr><tr><td style="text-align: left"><code>r, s := Intrinsic(x)</code></td><td style="text-align: left"><code>r, s = magf2.Intrinsic(x)</code></td></tr><tr><td style="text-align: left"><code>R&lt;x,y&gt; := Intrinsic(p, q)</code></td><td style="text-align: left"><code>R, x, y = magg.Intrinsic((:x, :y), p, q)</code></td></tr><tr><td style="text-align: left"><code>IntrinsicProcedure(x)</code></td><td style="text-align: left"><code>magp.IntrinsicProcedure(x)</code></td></tr><tr><td style="text-align: left"><code>IntrinsicProcedure(~x, y)</code></td><td style="text-align: left"><code>magp1.IntrinsicProcedure(x, y)</code> or <code>magp.IntrinsicProcedure(MagmaRef(x), y)</code></td></tr><tr><td style="text-align: left"><code>SomeType</code></td><td style="text-align: left"><code>magt.SomeType</code></td></tr><tr><td style="text-align: left"><code>x + y</code></td><td style="text-align: left"><code>magadd(x, y)</code> or <code>x + y</code></td></tr><tr><td style="text-align: left"><code>x - y</code></td><td style="text-align: left"><code>magsub(x, y)</code> or <code>x - y</code></td></tr><tr><td style="text-align: left"><code>x * y</code></td><td style="text-align: left"><code>magmul(x, y)</code> or <code>x * y</code></td></tr><tr><td style="text-align: left"><code>x / y</code></td><td style="text-align: left"><code>magtruediv(x, y)</code> or <code>x / y</code></td></tr><tr><td style="text-align: left"><code>x ^ y</code></td><td style="text-align: left"><code>magpow(x, y)</code> or <code>x ^ y</code></td></tr><tr><td style="text-align: left"><code>x diff y</code></td><td style="text-align: left"><code>magdiff(x, y)</code> or <code>setdiff(x, y)</code></td></tr><tr><td style="text-align: left"><code>x div y</code></td><td style="text-align: left"><code>magdiv(x, y)</code> or <code>div(x, y)</code></td></tr><tr><td style="text-align: left"><code>x join y</code></td><td style="text-align: left"><code>magjoin(x, y)</code> or <code>union(x, y)</code></td></tr><tr><td style="text-align: left"><code>x meet y</code></td><td style="text-align: left"><code>magmeet(x, y)</code> or <code>intersect(x, y)</code></td></tr><tr><td style="text-align: left"><code>x mod y</code></td><td style="text-align: left"><code>magmod(x, y)</code> or <code>mod(x, y)</code></td></tr><tr><td style="text-align: left"><code>x sdiff y</code></td><td style="text-align: left"><code>magsdiff(x, y)</code> or <code>symdiff(x, y)</code></td></tr><tr><td style="text-align: left"><code>x cat y</code></td><td style="text-align: left"><code>magcat(x, y)</code> or <code>cat(x, y)</code></td></tr><tr><td style="text-align: left"><code>x eq y</code></td><td style="text-align: left"><code>mageq(x, y)</code> or <code>x == y</code></td></tr><tr><td style="text-align: left"><code>x ne y</code></td><td style="text-align: left"><code>magne(x, y)</code> or <code>x != y</code></td></tr><tr><td style="text-align: left"><code>x cmpeq y</code></td><td style="text-align: left"><code>magcmpeq(x, y)</code></td></tr><tr><td style="text-align: left"><code>x cmpne y</code></td><td style="text-align: left"><code>magcmpne(x, y)</code></td></tr><tr><td style="text-align: left"><code>x le y</code></td><td style="text-align: left"><code>magle(x, y)</code> or <code>x &lt;= y</code></td></tr><tr><td style="text-align: left"><code>x lt y</code></td><td style="text-align: left"><code>maglt(x, y)</code> or <code>x &lt; y</code></td></tr><tr><td style="text-align: left"><code>x ge y</code></td><td style="text-align: left"><code>magge(x, y)</code> or <code>x &gt;= y</code></td></tr><tr><td style="text-align: left"><code>x gt y</code></td><td style="text-align: left"><code>maggt(x, y)</code> or <code>x &gt; y</code></td></tr><tr><td style="text-align: left"><code>x in y</code></td><td style="text-align: left"><code>magin(x, y)</code> or <code>x in y</code></td></tr><tr><td style="text-align: left"><code>x notin y</code></td><td style="text-align: left"><code>magnotin(x, y)</code></td></tr><tr><td style="text-align: left"><code>x adj y</code></td><td style="text-align: left"><code>magadj(x, y)</code></td></tr><tr><td style="text-align: left"><code>x notadj y</code></td><td style="text-align: left"><code>magnotadj(x, y)</code></td></tr><tr><td style="text-align: left"><code>x subset y</code></td><td style="text-align: left"><code>magsubset(x, y)</code> or <code>issubset(x, y)</code></td></tr><tr><td style="text-align: left"><code>x notsubset y</code></td><td style="text-align: left"><code>magnotsubset(x, y)</code></td></tr><tr><td style="text-align: left"><code>&amp;+ x</code></td><td style="text-align: left"><code>magsum(x)</code> or <code>sum(x)</code></td></tr><tr><td style="text-align: left"><code>&amp;* x</code></td><td style="text-align: left"><code>magprod(x)</code> or <code>prod(x)</code></td></tr><tr><td style="text-align: left"><code>&amp;and x</code></td><td style="text-align: left"><code>magreduceand(x)</code></td></tr><tr><td style="text-align: left"><code>&amp;or x</code></td><td style="text-align: left"><code>magreduceor(x)</code></td></tr><tr><td style="text-align: left"><code>&amp;join x</code></td><td style="text-align: left"><code>magreducejoin(x)</code></td></tr><tr><td style="text-align: left"><code>&amp;meet x</code></td><td style="text-align: left"><code>magreducemeet(x)</code></td></tr><tr><td style="text-align: left"><code>&amp;cat x</code></td><td style="text-align: left"><code>magreducecat(x)</code></td></tr><tr><td style="text-align: left"><code>[* a, b, c *]</code></td><td style="text-align: left"><code>maglist((a, b, c))</code></td></tr><tr><td style="text-align: left"><code>&lt; a, b, c &gt;</code></td><td style="text-align: left"><code>magtuple((a, b, c))</code></td></tr><tr><td style="text-align: left"><code>[ a, b, c ]</code></td><td style="text-align: left"><code>magseq((a, b, c))</code></td></tr><tr><td style="text-align: left"><code>[ U | a, b, c ]</code></td><td style="text-align: left"><code>magseq((a, b, c), universe=U)</code></td></tr><tr><td style="text-align: left"><code>[ a..b by c]</code></td><td style="text-align: left"><code>magseq(a:c:b)</code></td></tr><tr><td style="text-align: left"><code>{ a, b, c }</code></td><td style="text-align: left"><code>magset((a, b, c))</code></td></tr><tr><td style="text-align: left"><code>{* a, b, c *}</code></td><td style="text-align: left"><code>magmset((a, b, c))</code></td></tr><tr><td style="text-align: left"><code>{@ a, b, c @}</code></td><td style="text-align: left"><code>magiset((a, b, c))</code></td></tr><tr><td style="text-align: left"><code>print x</code></td><td style="text-align: left"><code>magprint(io, x)</code></td></tr><tr><td style="text-align: left"><code>print x: Magma</code></td><td style="text-align: left"><code>magprint(io, x, :magma)</code></td></tr><tr><td style="text-align: left"><code>Sprint(x, &quot;Magma&quot;)</code></td><td style="text-align: left"><code>magsprint(x, :magma)</code></td></tr><tr><td style="text-align: left"><code>x[i, j]</code></td><td style="text-align: left"><code>maggetindex(x, i, j)</code> or <code>x[i, j]</code></td></tr><tr><td style="text-align: left"><code>x[i, j] := y</code></td><td style="text-align: left"><code>magsetindex!(x, y, i, j)</code> or <code>x[i, j] = y</code></td></tr><tr><td style="text-align: left"><code># x</code></td><td style="text-align: left"><code>maglength(x)</code> (or <code>length(x)</code> provided the result is an integer)</td></tr><tr><td style="text-align: left"><code>x @ f</code></td><td style="text-align: left"><code>magimage(x, f)</code></td></tr><tr><td style="text-align: left"><code>x @@ f</code></td><td style="text-align: left"><code>magpreimage(x, f)</code></td></tr><tr><td style="text-align: left"><code>S ! x</code></td><td style="text-align: left"><code>magcoerce(S, x)</code></td></tr><tr><td style="text-align: left"><code>S.n</code></td><td style="text-align: left"><code>maggen(S, n)</code></td></tr><tr><td style="text-align: left"><code>x`attr</code></td><td style="text-align: left"><code>maggetattr(x, :attr)</code> or <code>x.attr</code></td></tr><tr><td style="text-align: left"><code>x`attr := y</code></td><td style="text-align: left"><code>magsetattr!(x, :attr, y)</code> or <code>x.attr = y</code></td></tr><tr><td style="text-align: left"><code>recformat&lt;r, s:RngInt&gt;</code></td><td style="text-align: left"><code>magrecformat(:r, :s=&gt;:RngInt)</code></td></tr><tr><td style="text-align: left"><code>rec&lt;fmt | r:=x&gt;</code></td><td style="text-align: left"><code>magrec(fmt, r=x)</code></td></tr><tr><td style="text-align: left"><code>? query</code></td><td style="text-align: left"><code>maghelp(&quot;query&quot;)</code></td></tr><tr><td style="text-align: left"><code>...any expression...</code></td><td style="text-align: left"><code>mag&quot;...&quot;</code> (supporting <code>$</code> interpolation)</td></tr></table><h2 id="Conversion-to-Magma"><a class="docs-heading-anchor" href="#Conversion-to-Magma">Conversion to Magma</a><a id="Conversion-to-Magma-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion-to-Magma" title="Permalink"></a></h2><p>When passed as arguments to Magma functions the following conversions are made from Julia types to Magma types:</p><table><tr><th style="text-align: left">Julia</th><th style="text-align: left">Magma</th></tr><tr><td style="text-align: left"><code>Bool</code></td><td style="text-align: left"><code>BoolElt</code></td></tr><tr><td style="text-align: left"><code>Integer</code></td><td style="text-align: left"><code>RngIntElt</code></td></tr><tr><td style="text-align: left"><code>Rational</code></td><td style="text-align: left"><code>FldRatElt</code></td></tr><tr><td style="text-align: left"><code>Real</code></td><td style="text-align: left"><code>FldReElt</code></td></tr><tr><td style="text-align: left"><code>Complex</code></td><td style="text-align: left"><code>FldComElt</code></td></tr><tr><td style="text-align: left"><code>AbstractString</code></td><td style="text-align: left"><code>MonStgElt</code></td></tr><tr><td style="text-align: left"><code>AbstractChar</code></td><td style="text-align: left"><code>MonStgElt</code> of length 1</td></tr><tr><td style="text-align: left"><code>AbstractVector</code></td><td style="text-align: left"><code>SeqEnum</code></td></tr><tr><td style="text-align: left"><code>AbstractSet</code></td><td style="text-align: left"><code>SetEnum</code></td></tr><tr><td style="text-align: left"><code>AbstractDict</code></td><td style="text-align: left"><code>Assoc</code></td></tr><tr><td style="text-align: left"><code>Tuple</code></td><td style="text-align: left"><code>Tup</code></td></tr><tr><td style="text-align: left"><code>NamedTuple</code></td><td style="text-align: left"><code>Rec</code></td></tr></table><h2 id="Conversion-to-Julia"><a class="docs-heading-anchor" href="#Conversion-to-Julia">Conversion to Julia</a><a id="Conversion-to-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion-to-Julia" title="Permalink"></a></h2><p>Call <code>magconvert(T, x)</code> to convert the Magma value <code>x</code> to a Julia <code>T</code>.</p><p>The following table gives the supported conversions. These are in preference order: the first type in each row that is a subtype of <code>T</code> is the return type from <code>magconvert</code>.</p><table><tr><th style="text-align: left">Magma</th><th style="text-align: left">Julia</th></tr><tr><td style="text-align: left"><code>RngIntElt</code> (integer)</td><td style="text-align: left"><code>BigInt</code>, <code>Int</code>, <code>UInt</code>, <code>Integer</code>, <code>Rational</code>, <code>Real</code>, <code>MagmaOTPInteger</code></td></tr><tr><td style="text-align: left"><code>FltRatElt</code> (rational)</td><td style="text-align: left"><code>Rational</code>, <code>Real</code>, <code>MagmaOTPRational</code></td></tr><tr><td style="text-align: left"><code>MonStgElt</code> (string)</td><td style="text-align: left"><code>String</code>, <code>AbstractString</code>, <code>Char</code>, <code>AbstractChar</code>, <code>Vector{UInt8}</code>, <code>AbstractVector{UInt8}</code>, <code>MagmaOTPString</code></td></tr><tr><td style="text-align: left"><code>List</code> (list)</td><td style="text-align: left"><code>Vector</code>, <code>AbstractVector</code>, <code>MagmaOTPList</code></td></tr><tr><td style="text-align: left"><code>SeqEnum</code> (sequence)</td><td style="text-align: left"><code>Vector</code>, <code>AbstractVector</code>, <code>MagmaOTPSequence</code></td></tr><tr><td style="text-align: left"><code>SetEnum</code> (set)</td><td style="text-align: left"><code>Set</code>, <code>AbstractSet</code>, <code>Vector</code>, <code>AbstractVector</code>, <code>MagmaOTPSet</code></td></tr></table><p>For sequences and sets, the result depends on whether it is a null sequence/set (in which case <code>MagmaOTPNullSequence</code> might be returned) or is a range (in which case a <code>StepRangeLen</code> is the preferred return type, and <code>MagmaOTPRangeSequence</code> is the least preferred).</p><p>The <code>MagmaOTP*</code> types are exact representations of objects from the Magma Object Transfer Protocol. They are all subtypes of <code>MagmaOTPValue</code>. They have no extra semantics, so are always the least-preferred option. Not included in the table are structures themselves (e.g. <code>RngInt</code> (ring of integers), <code>MonStg</code> (strings)) which are always converted to a corresponding <code>MagmaOTPStr</code>.</p><h2 id="Calling-functions-and-procedures"><a class="docs-heading-anchor" href="#Calling-functions-and-procedures">Calling functions and procedures</a><a id="Calling-functions-and-procedures-1"></a><a class="docs-heading-anchor-permalink" href="#Calling-functions-and-procedures" title="Permalink"></a></h2><p>In Magma, there is no syntactic difference between function calls and procedure calls, so in MagmaCall, we must make the distinction explicit.</p><p>The simplest way to call an intrinsic function is to use the syntax <code>magf.Intrinsic(...)</code>. Similarly <code>magp.Intrinsic(...)</code> is a procedure call (returning <code>nothing</code>) and <code>magf2.Intrinsic(...)</code> is a function call returning a pair of values.</p><p>For each &quot;calling convention&quot; <code>C</code> in the following table, there is a corresponding <code>magC</code> object which can be accessed in this way.</p><table><tr><th style="text-align: left">Convention</th><th style="text-align: left">Interpretation</th></tr><tr><td style="text-align: left">p</td><td style="text-align: left">Procedure call. Return <code>nothing</code>.</td></tr><tr><td style="text-align: left">f</td><td style="text-align: left">Function call. Return a <code>MagmaObject</code>.</td></tr><tr><td style="text-align: left">fN</td><td style="text-align: left">Function call with <code>N</code> return values. Return a tuple of <code>MagmaObject</code>.</td></tr><tr><td style="text-align: left">i</td><td style="text-align: left">Function call returning an integer. Return an <code>Int</code>.</td></tr><tr><td style="text-align: left">b</td><td style="text-align: left">Function call returning a boolean. Return a <code>Bool</code>.</td></tr><tr><td style="text-align: left">g</td><td style="text-align: left">Function call with generators, so that <code>R, x, y = magg.Intrinsic((:x, :y), ...)</code> is equivalent to <code>R&lt;x,y&gt; := Intrinsic(...)</code> in Magma.</td></tr><tr><td style="text-align: left">m</td><td style="text-align: left">Function call returning a bool and a value. Return <code>nothing</code> if the bool is false, else the value.</td></tr><tr><td style="text-align: left">pN</td><td style="text-align: left">Procedure call, passing the <code>N</code>th argument by reference. Return <code>nothing</code>.</td></tr></table><p>The way this works is that <code>magC.Intrinsic</code> is a <code>MagmaCallable{:C}</code>, which is a <code>MagmaValue</code> with function call syntax overloaded, so that <code>magC.Intrinsic(...)</code> is equivalent to <code>magcall(Val(:C), magC.Intrinsic, ...)</code>. <a href="../reference/#MagmaCall.magcall"><code>magcall</code></a> is the worker function where calling conventions are implemented.</p><p>If you have a Magma value <code>f</code> and need to call it, then <code>f(...)</code> will not work because the desired calling convention is unknown. Instead, use <code>magcall(Val(:C), f, ...)</code> or <code>magcallC(f, ...)</code>. Alternatively, you can explicitly wrap it as <code>MagmaCallable{:C}(f)</code> and call that.</p><p>Note also that <code>mag&quot;...&quot;C</code> is equivalent to <code>MagmaCallable{:C}(mag&quot;...&quot;)</code>.</p><p>The following are equivalent:</p><pre><code class="language-julia">magf.PolynomialRing(Z)
magcallf(:PolynomialRing, Z)
magcall(Val(:f), :PolynomialRing, Z)
MagmaCallable{:f}(MagmaIntrinsic(:PolynomialRing))(Z)
mag&quot;PolynomialRing&quot;f(Z)
mag&quot;PolynomialRing($Z)&quot;</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« MagmaCall.jl</a><a class="docs-footer-nextpage" href="../reference/">API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 30 September 2020 12:15">Wednesday 30 September 2020</span>. Using Julia version 1.5.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
